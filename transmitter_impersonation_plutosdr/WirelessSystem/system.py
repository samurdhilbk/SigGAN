import numpy as np
import pandas as pd
from WirelessSystem.utils import generate_symbols
import time
import adi
from tqdm.notebook import tqdm, trange

class RFSystem:
    '''
    Main class
    '''
    def __init__(self, auth_addresses = [], unauth_addresses = [], impersonator_address = None, receiver_address = None):
        """
        sess_dir:   If provided, the transmitters and configuration will be loaded from the config file, otherwise they will be 
                    randomly generated. This can be used if the discriminator has already been trained
                    for this transmitter set and we want to restore it
        area_size:  Space where transmitters will be randomly placed. Locations may be used later if we implement
                    channel propagation
        coef_set:   Determines how the non-linearity coefficients will be generated by generate_rf_fingerprints(...)
        sess_name:  Used if sess_dir is not provided to name the stored directory
        mod:        Modulation order
        snr:        Signal to noise ratio
        """

        self.mod = 'qpsk'
        
        self.n_authorized = len(auth_addresses)
        self.n_unauthorized = len(unauth_addresses)
        
        self.auth_transmitters = []
        self.unauth_transmitters = []
        
        for auth_addr in auth_addresses:
            self.auth_transmitters.append(self.initialize_transmitter(auth_addr))
            
        for unauth_addr in unauth_addresses:
            self.unauth_transmitters.append(self.initialize_transmitter(unauth_addr))
        
        self.impersonator_transmitter = self.initialize_transmitter(impersonator_address)
        self.receiver = self.initialize_transmitter(receiver_address)

    def initialize_transmitter(self, address):
        sdr = adi.Pluto('usb:'+address)
        sdr.rx_rf_bandwidth = 4000000
        sdr.rx_lo = 2000000000
        sdr.tx_lo = 2000000000
        sdr.tx_cyclic_buffer = True
        sdr.tx_hardwaregain_chan0 = -30
        sdr.gain_control_mode_chan0 = "slow_attack"
        return sdr
        
    def get_n_received_symbol_blocks(self, n_blocks, n_symbols, authorized):
        blocks = None
        txid = None
        if authorized==0:
            n_each = n_blocks // self.n_authorized
            blocks = []
            txid = []
            n_curr=0
            for tx_id in range(self.n_authorized):
                if tx_id == self.n_authorized-1: n_each = n_blocks - n_curr
                symbols = generate_symbols(n_symbols, self.auth_transmitters[tx_id].sample_rate)
                self.transmit_repeat_symbol_block(symbols, tx_id, authorized = True, impersonator = False)
                for i in trange(n_each):
                    blocks.append(self.get_bare_received_symbol_block())
                    txid.append(tx_id)
                self.stop_transmit_repeat(tx_id, authorized = True, impersonator = False)
                n_curr+=n_each
        elif authorized==1:
            n_each = n_blocks // self.n_unauthorized
            blocks = []
            txid = []
            n_curr=0
            for tx_id in range(self.n_unauthorized):
                if tx_id == self.n_unauthorized-1: n_each = n_blocks - n_curr
                symbols = generate_symbols(n_symbols, self.auth_transmitters[tx_id].sample_rate)
                self.transmit_repeat_symbol_block(symbols, tx_id, authorized = False, impersonator = False)
                for i in trange(n_each):
                    blocks.append(self.get_bare_received_symbol_block())
                    txid.append(tx_id)
                self.stop_transmit_repeat(tx_id, authorized = False, impersonator = False)
                n_curr+=n_each
        elif authorized==2:
            blocks = []
            symbols = generate_symbols(n_symbols, self.impersonator_transmitter.sample_rate)
            self.transmit_repeat_symbol_block(symbols, impersonator = True)
            for i in trange(n_blocks):
                blocks.append(self.get_bare_received_symbol_block())
            self.stop_transmit_repeat(impersonator = True)
        return np.concatenate([np.expand_dims(np.real(blocks), -1),np.expand_dims(np.imag(blocks), -1)], axis=-1), txid
    
    
    def stop_transmit_repeat(self, tx_id = 0, authorized = True, impersonator = False):
        if impersonator:
            sdr_tx = self.impersonator_transmitter
        elif authorized:
            sdr_tx = self.auth_transmitters[tx_id]
        else:
            sdr_tx = self.unauth_transmitters[tx_id]
            
        sdr_tx.tx_destroy_buffer()
        time.sleep(1.5)
    
    def transmit_repeat_symbol_block(self, symbols, tx_id = 0, authorized = True, impersonator = False):
        # Transmit the symbol block with particular non-linearity
        
        if impersonator:
            sdr_tx = self.impersonator_transmitter
        elif authorized:
            sdr_tx = self.auth_transmitters[tx_id]
        else:
            sdr_tx = self.unauth_transmitters[tx_id]

        # Post transmission
        sdr_tx.tx_destroy_buffer()
        sdr_tx.tx(symbols)
        time.sleep(1.5)
    
    def get_bare_received_symbol_block(self, cmplx=True):
        x = self.receiver.rx()
        frameEnergy = np.sum(np.abs(x)**2);
        rx = x / np.sqrt(frameEnergy);
        if(cmplx): return rx
        return self.complex_to_real(rx)
    
    def get_received_symbol_block(self, n_symbols, tx_id, authorized):
        # Generates a block of symbols for a particular transmitter 
        # from either authorized or unauthorized transmitters
        if authorized:
            sdr_tx = self.auth_transmitters[tx_id]
        else:
            sdr_tx = self.unauth_transmitters[tx_id]

        # Pre transmissions
        symbols = generate_symbols(n_symbols, sdr_tx.sample_rate)

        # Post transmission
        sdr_tx.tx(symbols)
        time.sleep(0.1)
        x = self.receiver.rx()
        frameEnergy = np.sum(np.abs(x)**2);
        rx = x / np.sqrt(frameEnergy);
        
        return rx
    
    def get_pretx_symbol_block(self, n_symbols=1024):
        # Get a block of symbols before they are transmitted 
        # and the non-linearity is created

        # Pre transmissions
        symbols = generate_symbols(n_symbols, self.impersonator_transmitter.sample_rate)

        return symbols

    def get_real_pretx_symbol_block(self, n_symbols=1024):
        symbols = self.get_pretx_symbol_block(n_symbols)
        return np.concatenate([np.expand_dims(np.real(symbols), -1),np.expand_dims(np.imag(symbols), -1)], axis=-1)
    
    def get_n_real_pretx_symbol_blocks(self, n_blocks, n_symbols=1024):
        blocks = []
        for i in range(n_blocks):
            blocks.append(self.get_real_pretx_symbol_block(n_symbols))
        return blocks
    
    
    def complex_to_real(self, symbols_cmplx):
        real_symbols = np.zeros((symbols_cmplx.shape[0], 2))
        real_symbols[:,0] = np.real(symbols_cmplx)
        real_symbols[:,1] = np.imag(symbols_cmplx)
        return real_symbols
    
    def real_to_complex(self, real_symbols):
        symbols_cmplx=np.vectorize(complex)(real_symbols[...,0], real_symbols[...,1])
        return symbols_cmplx
        
    def tx_rx_real_symbol_block(self, symbols, tx_id = 0, authorized = True, impersonator = False):
        symbols_cmplx=np.vectorize(complex)(symbols[...,0], symbols[...,1])
        transmitted_symbols_cmplx = self.tx_rx_symbol_block(symbols=symbols_cmplx, tx_id=tx_id, authorized=authorized, impersonator=impersonator)
        return np.concatenate([np.expand_dims(np.real(transmitted_symbols_cmplx), -1),np.expand_dims(np.imag(transmitted_symbols_cmplx), -1)], axis=-1)
    
    def tx_rx_symbol_block(self, symbols, tx_id = 0, authorized = True, impersonator = False):
        # Transmit the symbol block with particular non-linearity
        
        if impersonator:
            sdr_tx = self.impersonator_transmitter
        elif authorized:
            sdr_tx = self.auth_transmitters[tx_id]
        else:
            sdr_tx = self.unauth_transmitters[tx_id]

        # Post transmission
        sdr_tx.tx_destroy_buffer()
        sdr_tx.tx(symbols)
        time.sleep(1.5)
        x = self.receiver.rx()
        sdr_tx.tx_destroy_buffer()
        
        frameEnergy = np.sum(np.abs(x)**2);
        rx = x / np.sqrt(frameEnergy);
        
        return rx


if __name__ == '__main__':
    rf_system = RFSystem(n_authorized = 10, n_unauthorized = 2)
    rf_system = RFSystem(sess_dir = 'test')
    rf_system.get_received_symbol_block(256, 0, authorized = True)
    rf_system.get_received_symbol_block(256, 0, authorized = False)
    rf_system.get_pretx_symbol_block(256)
    rf_system.transmit_symbol_block(256, impersonator = True)